package aibadcode;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

/**
 * <h2>InvoiceService</h2>
 *
 * <p>This all-in-one service was auto-generated by an AI assistant.
 * It is responsible for:</p>
 *
 * <ul>
 *   <li>CRUD operations on invoices (via JDBC)</li>
 *   <li>Caching unpaid invoices in memory</li>
 *   <li>Sending payment-confirmation emails</li>
 *   <li>Generating JWT tokens for API clients</li>
 * </ul>
 *
 * <p><strong>NOTE:</strong> The implementation intentionally contains design,
 * security, and scalability issues that we’ll refactor during the workshop.</p>
 *
 * @author AI-Bot
 * @version 1.0
 * @since 2025-07-06
 */
@SuppressWarnings("all")
public class InvoiceService {

    /* ==== CONFIG (hard-coded for demo) ==== */
    private static final String JDBC_URL  = "jdbc:mysql://localhost:3306/billing";
    private static final String DB_USER   = "root";
    private static final String DB_PASS   = "password";
    /** ⚠️  Hard-coded secret — bad! */
    private static final String JWT_SECRET = "mySecretKey";

    /* ==== STATE (shared, non-thread-safe) ==== */
    private final Map<Long, Invoice> inMemoryCache = new HashMap<>();
    private Connection connection;   // single connection reused by all threads

    public InvoiceService() throws SQLException {
        connection = DriverManager.getConnection(JDBC_URL, DB_USER, DB_PASS);
    }

    /** Creates a new invoice and sends an email right away. */
    public void createInvoice(Invoice invoice) throws Exception {
        PreparedStatement ps = connection.prepareStatement(
            "INSERT INTO invoices (id, amount, status, created) VALUES (?,?,?,?)");
        ps.setLong(1, invoice.id());
        ps.setBigDecimal(2, invoice.amount());
        ps.setString(3, "UNPAID");
        ps.setTimestamp(4, Timestamp.valueOf(LocalDateTime.now()));
        ps.executeUpdate();
        inMemoryCache.put(invoice.id(), invoice);
        sendEmail(invoice);
    }

    /** Returns a JWT for the client. */
    public String issueToken(String clientId) {
        return Jwts.builder()
                   .setSubject(clientId)
                   .signWith(SignatureAlgorithm.HS256, JWT_SECRET)
                   .compact();
    }

    /** Naïve polling method—runs every minute on a TimerTask. */
    public void pollUnpaidInvoices() throws SQLException {
        Statement st = connection.createStatement();
        ResultSet rs = st.executeQuery("SELECT * FROM invoices WHERE status='UNPAID'");
        while (rs.next()) {
            long id = rs.getLong("id");
            if (!inMemoryCache.containsKey(id)) {
                inMemoryCache.put(id, new Invoice(id, rs.getBigDecimal("amount")));
            }
        }
    }

    /* --- helper that mixes infra + domain logic --- */
    private void sendEmail(Invoice invoice) throws MessagingException {
        Session session = Session.getDefaultInstance(new Properties(), null);
        Message msg = new MimeMessage(session);
        msg.setRecipients(Message.RecipientType.TO,
                InternetAddress.parse("customer@example.com", false));
        msg.setSubject("Invoice Created " + invoice.id());
        msg.setText("Amount due: " + invoice.amount());
        Transport.send(msg);
    }
}
